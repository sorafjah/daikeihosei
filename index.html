<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>台形補正アプリ</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body { background-color: #f8fafc; }
        .touch-none { touch-action: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        const App = () => {
            const [image, setImage] = useState(null);
            const [imgSize, setImgSize] = useState({ width: 0, height: 0 });
            const [points, setPoints] = useState([]); 
            const [draggingIdx, setDraggingIdx] = useState(null);
            const [resultImage, setResultImage] = useState(null);
            const [isProcessing, setIsProcessing] = useState(false);
            const [error, setError] = useState(null);

            const containerRef = useRef(null);
            const imgRef = useRef(null);

            // アイコンの初期化
            useEffect(() => {
                lucide.createIcons();
            }, [image, resultImage, isProcessing]);

            const handleImageLoad = (src) => {
                setError(null);
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.onload = () => {
                    setImage(img);
                    const w = img.width;
                    const h = img.height;
                    setImgSize({ width: w, height: h });
                    setPoints([
                        { x: w * 0.15, y: h * 0.15 },
                        { x: w * 0.85, y: h * 0.15 },
                        { x: w * 0.85, y: h * 0.85 },
                        { x: w * 0.15, y: h * 0.85 },
                    ]);
                    setResultImage(null);
                };
                img.onerror = () => setError("画像の読み込みに失敗しました。");
                img.src = src;
            };

            const onFileChange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (f) => handleImageLoad(f.target.result);
                    reader.readAsDataURL(file);
                }
            };

            useEffect(() => {
                const handlePaste = (e) => {
                    const items = e.clipboardData.items;
                    for (let i = 0; i < items.length; i++) {
                        if (items[i].type.indexOf('image') !== -1) {
                            const blob = items[i].getAsFile();
                            const reader = new FileReader();
                            reader.onload = (f) => handleImageLoad(f.target.result);
                            reader.readAsDataURL(blob);
                        }
                    }
                };
                window.addEventListener('paste', handlePaste);
                return () => window.removeEventListener('paste', handlePaste);
            }, []);

            const getMapping = useCallback(() => {
                if (!imgRef.current || !imgSize.width) return null;
                const rect = imgRef.current.getBoundingClientRect();
                return {
                    scaleX: imgSize.width / rect.width,
                    scaleY: imgSize.height / rect.height,
                    left: rect.left,
                    top: rect.top
                };
            }, [imgSize]);

            const handleStart = (e, idx) => {
                if (e.cancelable) e.preventDefault();
                setDraggingIdx(idx);
            };

            const handleMove = useCallback((e) => {
                if (draggingIdx === null || !image) return;
                const mapping = getMapping();
                if (!mapping) return;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const x = (clientX - mapping.left) * mapping.scaleX;
                const y = (clientY - mapping.top) * mapping.scaleY;
                const newPoints = [...points];
                newPoints[draggingIdx] = {
                    x: Math.max(0, Math.min(imgSize.width, x)),
                    y: Math.max(0, Math.min(imgSize.height, y))
                };
                setPoints(newPoints);
            }, [draggingIdx, points, imgSize, image, getMapping]);

            const handleEnd = () => setDraggingIdx(null);

            useEffect(() => {
                if (draggingIdx !== null) {
                    window.addEventListener('mousemove', handleMove);
                    window.addEventListener('mouseup', handleEnd);
                    window.addEventListener('touchmove', handleMove, { passive: false });
                    window.addEventListener('touchend', handleEnd);
                }
                return () => {
                    window.removeEventListener('mousemove', handleMove);
                    window.removeEventListener('mouseup', handleEnd);
                    window.removeEventListener('touchmove', handleMove);
                    window.removeEventListener('touchend', handleEnd);
                };
            }, [draggingIdx, handleMove]);

            const processImage = () => {
                if (!image) return;
                setIsProcessing(true);
                setError(null);
                setTimeout(() => {
                    try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        const w1 = Math.hypot(points[1].x - points[0].x, points[1].y - points[0].y);
                        const w2 = Math.hypot(points[2].x - points[3].x, points[2].y - points[3].y);
                        const h1 = Math.hypot(points[3].x - points[0].x, points[3].y - points[0].y);
                        const h2 = Math.hypot(points[2].x - points[1].x, points[2].y - points[1].y);
                        const destW = Math.round(Math.max(w1, w2));
                        const destH = Math.round(Math.max(h1, h2));
                        canvas.width = destW;
                        canvas.height = destH;
                        
                        const transform = getPerspectiveTransform(points, [{x:0,y:0}, {x:destW,y:0}, {x:destW,y:destH}, {x:0,y:destH}]);
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = imgSize.width;
                        tempCanvas.height = imgSize.height;
                        const tCtx = tempCanvas.getContext('2d');
                        tCtx.drawImage(image, 0, 0);
                        const srcData = tCtx.getImageData(0, 0, imgSize.width, imgSize.height).data;
                        const outData = ctx.createImageData(destW, destH);
                        const d = outData.data;

                        for (let y = 0; y < destH; y++) {
                            for (let x = 0; x < destW; x++) {
                                const srcPos = mapPoint(x, y, transform.inv);
                                const sx = Math.floor(srcPos.x);
                                const sy = Math.floor(srcPos.y);
                                if (sx >= 0 && sx < imgSize.width && sy >= 0 && sy < imgSize.height) {
                                    const outIdx = (y * destW + x) * 4;
                                    const srcIdx = (sy * imgSize.width + sx) * 4;
                                    d[outIdx] = srcData[srcIdx];
                                    d[outIdx + 1] = srcData[srcIdx + 1];
                                    d[outIdx + 2] = srcData[srcIdx + 2];
                                    d[outIdx + 3] = srcData[srcIdx + 3];
                                }
                            }
                        }
                        ctx.putImageData(outData, 0, 0);
                        setResultImage(canvas.toDataURL('image/png'));
                    } catch (err) {
                        setError("補正できませんでした。");
                    } finally {
                        setIsProcessing(false);
                    }
                }, 50);
            };

            function getPerspectiveTransform(src, dst) {
                const p = [];
                for (let i = 0; i < 4; i++) {
                    p.push([src[i].x, src[i].y, 1, 0, 0, 0, -dst[i].x * src[i].x, -dst[i].x * src[i].y, dst[i].x]);
                    p.push([0, 0, 0, src[i].x, src[i].y, 1, -dst[i].y * src[i].x, -dst[i].y * src[i].y, dst[i].y]);
                }
                const h = solveLinearEquations(p);
                h.push(1);
                return { mat: h, inv: invert3x3(h) };
            }

            function solveLinearEquations(matrix) {
                const n = 8;
                for (let i = 0; i < n; i++) {
                    let max = i;
                    for (let j = i + 1; j < n; j++) {
                        if (Math.abs(matrix[j][i]) > Math.abs(matrix[max][i])) max = j;
                    }
                    [matrix[i], matrix[max]] = [matrix[max], matrix[i]];
                    const pivot = matrix[i][i];
                    for (let j = i; j <= n; j++) matrix[i][j] /= pivot;
                    for (let j = 0; j < n; j++) {
                        if (i !== j) {
                            const factor = matrix[j][i];
                            for (let k = i; k <= n; k++) matrix[j][k] -= factor * matrix[i][k];
                        }
                    }
                }
                return matrix.map(row => row[n]);
            }

            function invert3x3(m) {
                const [a, b, c, d, e, f, g, h, i] = m;
                const det = a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);
                return [
                    (e * i - f * h) / det, (c * h - b * i) / det, (b * f - c * e) / det,
                    (f * g - d * i) / det, (a * i - c * g) / det, (c * d - a * f) / det,
                    (d * h - e * g) / det, (g * b - a * h) / det, (a * e - b * d) / det
                ];
            }

            function mapPoint(x, y, m) {
                const w = m[6] * x + m[7] * y + m[8];
                return {
                    x: (m[0] * x + m[1] * y + m[2]) / w,
                    y: (m[3] * x + m[4] * y + m[5]) / w
                };
            }

            return (
                <div className="min-h-screen flex flex-col p-4 font-sans text-slate-800">
                    <header className="mb-6 text-center">
                        <h1 className="text-3xl font-bold text-slate-900 tracking-tight">台形補正アプリ</h1>
                        <p className="text-slate-500 mt-1">斜めに写った書類をまっすぐに整えます</p>
                    </header>

                    <main className="flex-1 flex flex-col lg:flex-row gap-6 max-w-6xl mx-auto w-full">
                        <div className="flex-[2] bg-white rounded-2xl shadow-sm border border-slate-200 p-6 flex flex-col">
                            <div className="flex justify-between items-center mb-5 gap-3">
                                <h2 className="font-bold text-lg text-blue-600 flex items-center gap-2">
                                    <i data-lucide="move"></i>範囲を指定
                                </h2>
                                <label className="cursor-pointer bg-blue-600 hover:bg-blue-700 text-white px-5 py-2 rounded-xl transition-all flex items-center gap-2 text-sm font-semibold">
                                    <i data-lucide="upload"></i>画像を選択
                                    <input type="file" className="hidden" accept="image/*" onChange={onFileChange} />
                                </label>
                            </div>

                            <div ref={containerRef} className="relative flex-1 bg-slate-100 rounded-xl overflow-hidden min-h-[400px] flex items-center justify-center select-none touch-none border border-slate-200">
                                {!image ? (
                                    <div className="text-center text-slate-400 p-10">
                                        <i data-lucide="clipboard" className="mx-auto mb-4 opacity-20" style={{width: 48, height: 48}}></i>
                                        <p className="font-semibold text-slate-500">画像をここに貼り付け</p>
                                    </div>
                                ) : (
                                    <div className="relative inline-block max-w-full max-h-full">
                                        <img ref={imgRef} src={image.src} className="max-w-full max-h-[60vh] block object-contain shadow-sm" />
                                        <svg className="absolute top-0 left-0 w-full h-full pointer-events-none overflow-visible">
                                            <polygon 
                                                points={points.map(p => {
                                                    // imgRef.current が null の場合は計算をスキップ
                                                    if (!imgRef.current) return "0,0";
                                                    const rect = imgRef.current.getBoundingClientRect();
                                                    return `${(p.x / imgSize.width) * rect.width},${(p.y / imgSize.height) * rect.height}`;
                                                }).join(' ')}
                                                fill="rgba(37, 99, 235, 0.1)" stroke="#2563eb" strokeWidth="2"
                                            />
                                        </svg>
                                        {points.map((p, i) => {
                                            // imgRef.current がまだ無い場合は表示しない
                                            if (!imgRef.current) return null;
                                            const rect = imgRef.current.getBoundingClientRect();
                                            return (
                                                <div key={i} onMouseDown={(e) => handleStart(e, i)} onTouchStart={(e) => handleStart(e, i)}
                                                    className="absolute w-10 h-10 -ml-5 -mt-5 flex items-center justify-center cursor-grab active:cursor-grabbing z-20"
                                                    style={{ 
                                                        left: (p.x / imgSize.width) * rect.width, 
                                                        top: (p.y / imgSize.height) * rect.height 
                                                    }}
                                                >
                                                    <div className="w-6 h-6 bg-white border-2 border-blue-600 rounded-full shadow-md flex items-center justify-center">
                                                        <div className="w-2.5 h-2.5 bg-blue-600 rounded-full"></div>
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                )}
                            </div>
                            <div className="mt-6">
                                <button onClick={processImage} disabled={!image || isProcessing}
                                    className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 rounded-xl shadow-md transition-all disabled:opacity-50 flex items-center justify-center gap-2 text-lg">
                                    <i data-lucide={isProcessing ? "refresh-cw" : "square"} className={isProcessing ? "animate-spin" : ""}></i>
                                    {isProcessing ? "補正中..." : "長方形に整える"}
                                </button>
                            </div>
                        </div>

                        <div className="flex-1 flex flex-col gap-6">
                            <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-6 flex flex-col flex-1">
                                <h2 className="font-bold text-lg mb-4 flex items-center gap-2 text-slate-700">
                                    <i data-lucide="check-circle"></i>補正結果
                                </h2>
                                <div className="flex-1 bg-slate-50 rounded-xl overflow-hidden flex items-center justify-center border-2 border-dashed border-slate-200 relative min-h-[200px]">
                                    {resultImage ? <img src={resultImage} className="max-w-full max-h-full object-contain" /> : <div className="text-center text-slate-400 text-sm">結果がここに表示されます</div>}
                                </div>
                                <button disabled={!resultImage} onClick={() => { const a = document.createElement('a'); a.href = resultImage; a.download = 'fixed.png'; a.click(); }}
                                    className="mt-4 w-full py-3 bg-green-600 hover:bg-green-700 text-white rounded-xl font-bold flex items-center justify-center gap-2 transition-all disabled:opacity-50 shadow-sm">
                                    <i data-lucide="download"></i>保存する
                                </button>
                                {resultImage && <p className="mt-2 text-[10px] text-slate-400 text-center">※iPhoneは画像を長押しでカメラロールに保存</p>}
                            </div>

                            <div className="bg-slate-100 rounded-2xl p-6 border border-slate-200 shadow-sm">
                                <h3 className="font-bold text-sm mb-4 flex items-center gap-2 text-slate-600"><i data-lucide="mouse-pointer-2"></i>使いかた</h3>
                                <ul className="text-xs space-y-4 text-slate-600">
                                    <li className="flex gap-3"><span className="bg-blue-600 text-white w-4 h-4 rounded-full flex items-center justify-center flex-shrink-0 text-[10px]">1</span>画像を選択、またはコピペ</li>
                                    <li className="flex gap-3"><span className="bg-blue-600 text-white w-4 h-4 rounded-full flex items-center justify-center flex-shrink-0 text-[10px]">2</span>「長方形に整える」を押す</li>
                                    <li className="flex gap-3"><span className="bg-blue-600 text-white w-4 h-4 rounded-full flex items-center justify-center flex-shrink-0 text-[10px]">3</span>青い丸を角にぴったり合わせる</li>
                                    <li className="flex gap-3"><span className="bg-blue-600 text-white w-4 h-4 rounded-full flex items-center justify-center flex-shrink-0 text-[10px]">4</span>「長方形に整える」をもう一度押す</li>
                                    <li className="flex gap-3 border-t border-slate-200 pt-3"><span className="bg-green-600 text-white w-4 h-4 rounded-full flex items-center justify-center flex-shrink-0 text-[10px]">5</span>「保存する」をタップ、または画像を長押し</li>
                                </ul>
                            </div>
                        </div>
                    </main>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
