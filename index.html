import React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';
import { Upload, Download, Square, Move, Scissors, Clipboard, RefreshCw, Image as ImageIcon, Sparkles, CheckCircle, MousePointer2 } from 'lucide-react';

const App = () => {
  const [image, setImage] = useState(null);
  const [imgSize, setImgSize] = useState({ width: 0, height: 0 });
  const [points, setPoints] = useState([]); // [{x, y}, ...] - Image pixel coordinates
  const [draggingIdx, setDraggingIdx] = useState(null);
  const [resultImage, setResultImage] = useState(null);
  const [isProcessing, setIsProcessing] = useState(false);
  const [error, setError] = useState(null);

  const containerRef = useRef(null);
  const imgRef = useRef(null);

  // Load image helper
  const handleImageLoad = (src) => {
    setError(null);
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => {
      setImage(img);
      const w = img.width;
      const h = img.height;
      setImgSize({ width: w, height: h });
      
      // Initial points as 15% margin from edges
      setPoints([
        { x: w * 0.15, y: h * 0.15 }, // Top-Left
        { x: w * 0.85, y: h * 0.15 }, // Top-Right
        { x: w * 0.85, y: h * 0.85 }, // Bottom-Right
        { x: w * 0.15, y: h * 0.85 }, // Bottom-Left
      ]);
      setResultImage(null);
    };
    img.onerror = () => setError("ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚å½¢å¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
    img.src = src;
  };

  const onFileChange = (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (f) => handleImageLoad(f.target.result);
      reader.readAsDataURL(file);
    }
  };

  // Clipboard Paste Support
  useEffect(() => {
    const handlePaste = (e) => {
      const items = e.clipboardData.items;
      for (let i = 0; i < items.length; i++) {
        if (items[i].type.indexOf('image') !== -1) {
          const blob = items[i].getAsFile();
          const reader = new FileReader();
          reader.onload = (f) => handleImageLoad(f.target.result);
          reader.readAsDataURL(blob);
        }
      }
    };
    window.addEventListener('paste', handlePaste);
    return () => window.removeEventListener('paste', handlePaste);
  }, []);

  const getMapping = useCallback(() => {
    if (!imgRef.current || !imgSize.width) return null;
    const rect = imgRef.current.getBoundingClientRect();
    return {
      scaleX: imgSize.width / rect.width,
      scaleY: imgSize.height / rect.height,
      left: rect.left,
      top: rect.top,
      width: rect.width,
      height: rect.height
    };
  }, [imgSize]);

  const handleStart = (e, idx) => {
    e.preventDefault();
    setDraggingIdx(idx);
  };

  const handleMove = useCallback((e) => {
    if (draggingIdx === null || !image) return;
    const mapping = getMapping();
    if (!mapping) return;

    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

    const x = (clientX - mapping.left) * mapping.scaleX;
    const y = (clientY - mapping.top) * mapping.scaleY;

    const newPoints = [...points];
    newPoints[draggingIdx] = {
      x: Math.max(0, Math.min(imgSize.width, x)),
      y: Math.max(0, Math.min(imgSize.height, y))
    };
    setPoints(newPoints);
  }, [draggingIdx, points, imgSize, image, getMapping]);

  const handleEnd = () => setDraggingIdx(null);

  useEffect(() => {
    if (draggingIdx !== null) {
      window.addEventListener('mousemove', handleMove);
      window.addEventListener('mouseup', handleEnd);
      window.addEventListener('touchmove', handleMove, { passive: false });
      window.addEventListener('touchend', handleEnd);
    }
    return () => {
      window.removeEventListener('mousemove', handleMove);
      window.removeEventListener('mouseup', handleEnd);
      window.removeEventListener('touchmove', handleMove);
      window.removeEventListener('touchend', handleEnd);
    };
  }, [draggingIdx, handleMove]);

  // Perspective Transform Logic
  const processImage = () => {
    if (!image) return;
    setIsProcessing(true);
    setError(null);

    setTimeout(() => {
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        const w1 = Math.hypot(points[1].x - points[0].x, points[1].y - points[0].y);
        const w2 = Math.hypot(points[2].x - points[3].x, points[2].y - points[3].y);
        const h1 = Math.hypot(points[3].x - points[0].x, points[3].y - points[0].y);
        const h2 = Math.hypot(points[2].x - points[1].x, points[2].y - points[1].y);
        
        const destW = Math.round(Math.max(w1, w2));
        const destH = Math.round(Math.max(h1, h2));

        if (destW < 10 || destH < 10) throw new Error("ç¯„å›²ãŒå°ã•ã™ãã¾ã™ã€‚ã‚‚ã£ã¨åºƒã’ã¦ãã ã•ã„ã€‚");

        canvas.width = destW;
        canvas.height = destH;

        const transform = getPerspectiveTransform(points, [{x:0,y:0}, {x:destW,y:0}, {x:destW,y:destH}, {x:0,y:destH}]);

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = imgSize.width;
        tempCanvas.height = imgSize.height;
        const tCtx = tempCanvas.getContext('2d');
        tCtx.drawImage(image, 0, 0);
        const srcData = tCtx.getImageData(0, 0, imgSize.width, imgSize.height).data;

        const outData = ctx.createImageData(destW, destH);
        const d = outData.data;

        for (let y = 0; y < destH; y++) {
          for (let x = 0; x < destW; x++) {
            const srcPos = mapPoint(x, y, transform.inv);
            const sx = Math.floor(srcPos.x);
            const sy = Math.floor(srcPos.y);

            if (sx >= 0 && sx < imgSize.width && sy >= 0 && sy < imgSize.height) {
              const outIdx = (y * destW + x) * 4;
              const srcIdx = (sy * imgSize.width + sx) * 4;
              d[outIdx] = srcData[srcIdx];
              d[outIdx + 1] = srcData[srcIdx + 1];
              d[outIdx + 2] = srcData[srcIdx + 2];
              d[outIdx + 3] = srcData[srcIdx + 3];
            }
          }
        }

        ctx.putImageData(outData, 0, 0);
        setResultImage(canvas.toDataURL('image/png'));
      } catch (err) {
        setError(err.message || "è£œæ­£ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚");
      } finally {
        setIsProcessing(false);
      }
    }, 50);
  };

  function getPerspectiveTransform(src, dst) {
    const p = [];
    for (let i = 0; i < 4; i++) {
      p.push([src[i].x, src[i].y, 1, 0, 0, 0, -dst[i].x * src[i].x, -dst[i].x * src[i].y, dst[i].x]);
      p.push([0, 0, 0, src[i].x, src[i].y, 1, -dst[i].y * src[i].x, -dst[i].y * src[i].y, dst[i].y]);
    }
    const h = solveLinearEquations(p);
    h.push(1);
    return { mat: h, inv: invert3x3(h) };
  }

  function solveLinearEquations(matrix) {
    const n = 8;
    for (let i = 0; i < n; i++) {
      let max = i;
      for (let j = i + 1; j < n; j++) {
        if (Math.abs(matrix[j][i]) > Math.abs(matrix[max][i])) max = j;
      }
      [matrix[i], matrix[max]] = [matrix[max], matrix[i]];
      const pivot = matrix[i][i];
      if (Math.abs(pivot) < 1e-10) throw new Error("è¨ˆç®—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ç‚¹ã‚’å°‘ã—å‹•ã‹ã—ã¦ã¿ã¦ãã ã•ã„ã€‚");
      for (let j = i; j <= n; j++) matrix[i][j] /= pivot;
      for (let j = 0; j < n; j++) {
        if (i !== j) {
          const factor = matrix[j][i];
          for (let k = i; k <= n; k++) matrix[j][k] -= factor * matrix[i][k];
        }
      }
    }
    return matrix.map(row => row[n]);
  }

  function invert3x3(m) {
    const [a, b, c, d, e, f, g, h, i] = m;
    const det = a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);
    return [
      (e * i - f * h) / det, (c * h - b * i) / det, (b * f - c * e) / det,
      (f * g - d * i) / det, (a * i - c * g) / det, (c * d - a * f) / det,
      (d * h - e * g) / det, (g * b - a * h) / det, (a * e - b * d) / det
    ];
  }

  function mapPoint(x, y, m) {
    const w = m[6] * x + m[7] * y + m[8];
    return {
      x: (m[0] * x + m[1] * y + m[2]) / w,
      y: (m[3] * x + m[4] * y + m[5]) / w
    };
  }

  const loadSample = () => {
    const canvas = document.createElement('canvas');
    canvas.width = 800;
    canvas.height = 600;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#e2e8f0';
    ctx.fillRect(0, 0, 800, 600);
    ctx.fillStyle = '#4f46e5';
    ctx.beginPath();
    ctx.moveTo(200, 150); ctx.lineTo(650, 100); ctx.lineTo(580, 500); ctx.lineTo(150, 450);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = 'white';
    ctx.font = 'bold 36px sans-serif';
    ctx.fillText('SAMPLE DOCUMENT', 220, 310);
    handleImageLoad(canvas.toDataURL());
  };

  return (
    <div className="min-h-screen bg-orange-50/30 flex flex-col p-4 font-sans text-slate-800">
      <header className="mb-8 text-center">
        <h1 className="text-4xl font-black text-orange-600 flex items-center justify-center gap-3 tracking-tight">
          <Sparkles className="w-10 h-10" />
          å°å½¢è£œæ­£ã™ã‚‹ã‚¢ãƒ—ãƒª
        </h1>
        <p className="text-slate-500 mt-2 font-medium">ãªãªã‚ã®å†™çœŸã‚’ã€Œã‚·ãƒ£ã‚­ãƒ¼ãƒ³ï¼ã€ã¨ã¾ã£ã™ãã«âœ¨</p>
      </header>

      <main className="flex-1 flex flex-col lg:flex-row gap-8 max-w-6xl mx-auto w-full">
        {/* Editor Area */}
        <div className="flex-[2] bg-white rounded-3xl shadow-xl p-6 flex flex-col border border-orange-100">
          <div className="flex flex-wrap justify-between items-center mb-5 gap-3">
            <h2 className="font-bold text-xl flex items-center gap-2 text-indigo-700">
              <Move className="w-6 h-6" />
              1. ã‚«ãƒ‰ã‚’åˆã‚ã›ã‚‹
            </h2>
            <div className="flex gap-2">
              <button 
                onClick={loadSample}
                className="bg-slate-100 hover:bg-slate-200 text-slate-600 px-4 py-2 rounded-xl transition-all flex items-center gap-2 text-sm border border-slate-200 font-bold"
              >
                <ImageIcon className="w-4 h-4" />
                è¦‹æœ¬ã§è©¦ã™
              </button>
              <label className="cursor-pointer bg-orange-500 hover:bg-orange-600 text-white px-5 py-2 rounded-xl transition-all flex items-center gap-2 text-sm shadow-md font-bold">
                <Upload className="w-4 h-4" />
                ç”»åƒã‚’é¸ã¶
                <input type="file" className="hidden" accept="image/*" onChange={onFileChange} />
              </label>
            </div>
          </div>

          {error && (
            <div className="mb-5 p-4 bg-red-50 border border-red-200 text-red-600 rounded-2xl flex items-center gap-3 text-sm animate-pulse">
              <AlertCircle className="w-5 h-5 flex-shrink-0" />
              {error}
            </div>
          )}

          <div 
            ref={containerRef}
            className="relative flex-1 bg-slate-100 rounded-2xl overflow-hidden min-h-[450px] flex items-center justify-center select-none touch-none border-4 border-white shadow-inner"
            style={{ cursor: draggingIdx !== null ? 'grabbing' : 'crosshair' }}
          >
            {!image ? (
              <div className="text-center text-slate-300 p-10 bg-white/50 rounded-full">
                <div className="w-20 h-20 bg-white rounded-full flex items-center justify-center mx-auto mb-6 shadow-sm border border-slate-100">
                  <Clipboard className="w-10 h-10 opacity-30" />
                </div>
                <p className="text-xl font-black text-slate-400">ç”»åƒã‚’ã“ã“ã«è²¼ã‚Šä»˜ã‘ï¼</p>
                <p className="text-sm mt-2 opacity-70">ã¾ãŸã¯ã€ä¸Šã®ãƒœã‚¿ãƒ³ã‹ã‚‰é¸ã‚“ã§ã­</p>
              </div>
            ) : (
              <div className="relative inline-block max-w-full max-h-full">
                <img 
                  ref={imgRef}
                  src={image.src} 
                  alt="Source" 
                  className="max-w-full max-h-[65vh] block object-contain shadow-xl rounded-sm"
                />
                
                {/* SVG Overlay */}
                <svg className="absolute top-0 left-0 w-full h-full pointer-events-none overflow-visible">
                  <polygon 
                    points={points.map(p => {
                      if (!imgRef.current) return "0,0";
                      const rect = imgRef.current.getBoundingClientRect();
                      const x = (p.x / imgSize.width) * rect.width;
                      const y = (p.y / imgSize.height) * rect.height;
                      return `${x},${y}`;
                    }).join(' ')}
                    fill="rgba(249, 115, 22, 0.2)"
                    stroke="#f97316"
                    strokeWidth="4"
                    strokeLinejoin="round"
                    strokeDasharray="8 4"
                  />
                </svg>

                {/* Handles */}
                {points.map((p, i) => {
                  if (!imgRef.current) return null;
                  const rect = imgRef.current.getBoundingClientRect();
                  const x = (p.x / imgSize.width) * rect.width;
                  const y = (p.y / imgSize.height) * rect.height;
                  
                  return (
                    <div
                      key={i}
                      onMouseDown={(e) => handleStart(e, i)}
                      onTouchStart={(e) => handleStart(e, i)}
                      className="absolute w-12 h-12 -ml-6 -mt-6 flex items-center justify-center cursor-grab active:cursor-grabbing z-20 group"
                      style={{ left: x, top: y }}
                    >
                      <div className="w-6 h-6 bg-white border-4 border-orange-500 rounded-full shadow-lg group-hover:scale-125 transition-transform flex items-center justify-center">
                        <div className="w-2 h-2 bg-orange-500 rounded-full"></div>
                      </div>
                    </div>
                  );
                })}
              </div>
            )}
          </div>

          <div className="mt-6 flex gap-4">
            <button
              onClick={processImage}
              disabled={!image || isProcessing}
              className="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-black py-4 rounded-2xl shadow-lg transition-all disabled:opacity-50 flex items-center justify-center gap-3 text-xl hover:scale-[1.02] active:scale-95"
            >
              {isProcessing ? (
                <RefreshCw className="w-7 h-7 animate-spin" />
              ) : (
                <Square className="w-7 h-7" />
              )}
              {isProcessing ? "é­”æ³•ã‚’ã‹ã‘ã¦ã¾ã™..." : "é•·æ–¹å½¢ã«æ•´ãˆã‚‹ï¼"}
            </button>
          </div>
        </div>

        {/* Sidebar */}
        <div className="flex-1 flex flex-col gap-8">
          {/* Result Card */}
          <div className="bg-white rounded-3xl shadow-xl p-6 flex flex-col flex-1 border border-green-100">
            <h2 className="font-bold text-xl mb-5 flex items-center gap-2 text-green-600">
              <CheckCircle className="w-6 h-6" />
              2. å®Œæˆï¼
            </h2>
            <div className="flex-1 bg-slate-50 rounded-2xl overflow-hidden flex items-center justify-center border-2 border-dashed border-slate-200 relative min-h-[250px] shadow-inner">
              {resultImage ? (
                <img src={resultImage} alt="Result" className="max-w-full max-h-full object-contain p-2" />
              ) : (
                <div className="text-center text-slate-400 text-sm px-6 font-medium">
                  <p>å·¦ã®ç”»é¢ã§è§’ã‚’åˆã‚ã›ã¦ã‹ã‚‰</p>
                  <p className="font-bold text-indigo-500 my-1 text-base">ã€Œæ•´ãˆã‚‹ã€ãƒœã‚¿ãƒ³</p>
                  <p>ã‚’æŠ¼ã™ã¨ã“ã“ã«è¡¨ç¤ºã•ã‚Œã‚‹ã‚ˆï¼</p>
                </div>
              )}
            </div>
            
            <div className="mt-5">
              <button
                disabled={!resultImage}
                onClick={() => {
                  const link = document.createElement('a');
                  link.download = `shaki-n_${Date.now()}.png`;
                  link.href = resultImage;
                  link.click();
                }}
                className="w-full py-4 px-4 bg-green-600 hover:bg-green-700 text-white rounded-2xl font-black flex items-center justify-center gap-2 transition-all disabled:opacity-50 shadow-md hover:scale-[1.02] active:scale-95"
              >
                <Download className="w-6 h-6" />
                ãã‚Œã„ã«ä¿å­˜ã™ã‚‹
              </button>
            </div>
          </div>

          {/* Tips Card */}
          <div className="bg-gradient-to-br from-amber-400 to-orange-500 text-white rounded-3xl p-6 shadow-xl relative overflow-hidden">
            <div className="absolute top-[-10px] right-[-10px] opacity-10 rotate-12">
              <Sparkles className="w-32 h-32" />
            </div>
            <h3 className="font-black text-lg mb-4 flex items-center gap-2">
              <MousePointer2 className="w-5 h-5" />
              ã†ã¾ãä½¿ã†ã‚³ãƒ„ ğŸ’¡
            </h3>
            <ul className="text-sm space-y-4 font-bold">
              <li className="flex gap-3 items-start">
                <span className="bg-white/20 px-2 py-0.5 rounded text-xs">01</span>
                <span>ã¾ãšã¯ç”»é¢ã‚’<b>ãƒãƒãƒƒã¨ã‚¯ãƒªãƒƒã‚¯</b>ã—ã¦ã‹ã‚‰è²¼ã‚Šä»˜ã‘ã¦ã­ï¼</span>
              </li>
              <li className="flex gap-3 items-start">
                <span className="bg-white/20 px-2 py-0.5 rounded text-xs">02</span>
                <span>é’ã„ç‚¹ã‚’æ›¸é¡ã®è§’ã«<b>ãƒ”ãƒƒã‚¿ãƒª</b>åˆã‚ã›ã‚‹ã¨ã€é­”æ³•ã¿ãŸã„ã«ç¶ºéº—ã«ãªã‚Šã¾ã™âœ¨</span>
              </li>
              <li className="flex gap-3 items-start">
                <span className="bg-white/20 px-2 py-0.5 rounded text-xs">03</span>
                <span>ã‚¹ãƒãƒ›ã§ã‚‚<b>æŒ‡ä¸€æœ¬ã§ã‚«ãƒ³ã‚¿ãƒ³</b>ã«èª¿æ•´ã§ãã¾ã™ã€‚ã‚¹ã‚¤ã‚¹ã‚¤å‹•ã‹ã—ã¦ã¿ã¦ğŸ‘</span>
              </li>
            </ul>
          </div>
        </div>
      </main>
    </div>
  );
};

export default App;
